## The Ambient Commerce Protocol (ACP) Specification

### Protocol Principles

1. **Intents are persistent fields, not transient messages**
2. **Matching is continuous discovery, not discrete events**  
3. **Settlement is deterministic and reversible**
4. **All state transitions are cryptographically provable**
5. **Complexity emerges from simple rules**

### Core Protocol Messages

```ocaml
(* Level 0: Identity & Presence *)
type agent_announce = {
  agent_id: public_key;
  capabilities: capability list;
  proof_of_authority: signature;  (* Proves control of resources *)
  heartbeat_interval: duration;
  protocol_version: version;
}

(* Level 1: Intent Declaration *)
type intent_message = {
  intent_id: uuid;
  agent_id: public_key;
  
  (* The economic field this intent creates *)
  offer_field: resource_field;
  want_field: resource_field;
  
  (* Constraints define the shape of possible matches *)
  constraints: constraint_function;
  
  (* Temporal dynamics *)
  lifecycle: lifecycle_function;
  
  (* Cryptographic commitment *)
  commitment: hash;
  reveal_deadline: timestamp;
}

and resource_field = {
  resource_type: uri;  (* ontology reference *)
  quantity_range: (rational * rational);
  quality_function: quality -> float;  (* Maps quality to acceptability *)
  location_gradient: location -> float;  (* Spatial preferences *)
}

and constraint_function = 
  | Hard of (state -> bool)  (* Must be satisfied *)
  | Soft of (state -> float)  (* Preference gradient 0-1 *)
  | Composite of constraint_function list

(* Level 2: Discovery & Matching *)
type match_discovery = {
  match_id: uuid;
  intents: (intent_id * intent_id) list;  (* Can be multi-party *)
  settlement_space: settlement_manifold;  (* All possible settlements *)
  optimality_gradient: point -> float;  (* Which settlements are better *)
  discovered_at: timestamp;
  discoverer: agent_id;  (* Who found this match *)
}

and settlement_manifold = {
  dimensions: parameter list;  (* price, time, quality, etc *)
  valid_region: point -> bool;  (* Which points are valid settlements *)
  pareto_frontier: point list;  (* Optimal points *)
}

(* Level 3: Negotiation *)
type negotiation_message = 
  | Propose of {
      match_id: uuid;
      settlement_point: point;
      valid_until: timestamp;
    }
  | Counter of {
      match_id: uuid;
      previous: uuid;
      settlement_point: point;
      valid_until: timestamp;
    }
  | Accept of {
      match_id: uuid;
      settlement_point: point;
      commitment_proof: proof;
    }
  | Reject of {
      match_id: uuid;
      reason: rejection_reason;
    }

(* Level 4: Settlement *)
type settlement_message = {
  settlement_id: uuid;
  match_id: uuid;
  
  (* The agreed point in settlement space *)
  settlement_point: point;
  
  (* State transition *)
  pre_state: state_proof;
  post_state: state_proof;
  
  (* Execution proof *)
  execution_proof: merkle_proof;
  
  (* Reversal window *)
  reversible_until: timestamp option;
  reversal_bond: resource option;
}
```

### Protocol State Machine

```ocaml
(* Each agent maintains this state *)
type agent_state = {
  (* Active intents this agent has posted *)
  my_intents: (uuid, intent_message) map;
  
  (* Discovered matches involving this agent *)
  pending_matches: (uuid, match_discovery) map;
  
  (* Active negotiations *)
  negotiations: (uuid, negotiation_state) map;
  
  (* Completed settlements *)
  settlements: (uuid, settlement_message) map;
  
  (* Network view *)
  known_agents: (public_key, agent_info) map;
  intent_pool: (uuid, intent_message) map;  (* All known intents *)
}

(* State transitions *)
type state_transition =
  | PostIntent of intent_message
  | DiscoverMatch of match_discovery  
  | InitiateNegotiation of negotiation_message
  | SettleMatch of settlement_message
  | ReverseSettlement of uuid * reason
```

### The Matching Algorithm

```ocaml
module Matching = struct
  (* Continuous matching runs in background *)
  let continuous_match_loop state =
    let rec loop () =
      (* Sample the intent pool *)
      let intents = sample_intents state.intent_pool in
      
      (* Find compatible intent pairs *)
      let candidates = 
        intents 
        |> generate_pairs
        |> filter (fun (a,b) -> compatible a b)
      in
      
      (* For each candidate, compute settlement space *)
      let matches = 
        candidates
        |> List.map (fun (a,b) -> 
            let manifold = compute_settlement_manifold a b in
            { match_id = new_uuid();
              intents = [a.intent_id; b.intent_id];
              settlement_space = manifold;
              optimality_gradient = compute_gradient manifold;
              discovered_at = now();
              discoverer = state.my_id; })
        |> filter (fun m -> not (is_empty m.settlement_space))
      in
      
      (* Broadcast discoveries *)
      List.iter broadcast_match matches;
      
      (* Sleep briefly then continue *)
      sleep matching_interval;
      loop ()
    in
    loop ()
    
  (* Check if two intents can potentially match *)
  and compatible intent_a intent_b =
    (* Resources must be exchangeable *)
    resources_compatible intent_a.offer_field intent_b.want_field &&
    resources_compatible intent_b.offer_field intent_a.want_field &&
    (* Constraints must have overlap *)
    constraints_overlap intent_a.constraints intent_b.constraints &&
    (* Lifecycles must intersect *)
    lifecycles_intersect intent_a.lifecycle intent_b.lifecycle
    
  (* Compute all possible settlements *)
  and compute_settlement_manifold intent_a intent_b =
    (* This is where the magic happens *)
    (* The manifold is the space of all valid trades *)
    let price_range = 
      intersect intent_a.offer_field.quantity_range 
                intent_b.want_field.quantity_range in
    let time_range = 
      intersect (get_time_window intent_a)
                (get_time_window intent_b) in
    let quality_range =
      intersect (get_quality_range intent_a)
                (get_quality_range intent_b) in
    
    { dimensions = ["price"; "time"; "quality"];
      valid_region = (fun point ->
        in_range point "price" price_range &&
        in_range point "time" time_range &&
        in_range point "quality" quality_range &&
        satisfies_constraints point intent_a.constraints &&
        satisfies_constraints point intent_b.constraints);
      pareto_frontier = compute_pareto_frontier price_range time_range quality_range }
end
```

### Trust & Safety Protocol

```ocaml
module Trust = struct
  (* Every message includes proof of capability *)
  type capability_proof = {
    capability: capability;
    evidence: evidence;
    issued_by: authority;
    valid_until: timestamp;
    signature: signature;
  }
  
  (* Agents build reputation through settlements *)
  type reputation_update = {
    agent: public_key;
    settlement: settlement_id;
    outcome: outcome;
    peer_attestation: attestation option;
  }
  
  (* Collateral for reversible settlements *)
  type collateral_lock = {
    resource: resource;
    locked_until: timestamp;
    unlock_condition: state -> bool;
    beneficiary: public_key;
  }
  
  (* Dispute resolution *)
  type dispute = {
    settlement_id: uuid;
    complainant: public_key;
    claim: claim;
    evidence: evidence list;
    arbiter: arbiter_selection;
  }
end
```

### Network Protocol

```ocaml
module Network = struct
  (* How intents propagate through the network *)
  type propagation_strategy =
    | Flood  (* Send to all known agents *)
    | Gossip of { fanout: int; ttl: int }  
    | DHT of { key: bytes; redundancy: int }
    | Targeted of { criteria: agent_info -> bool }
  
  (* Network messages *)
  type network_message =
    | Intent of intent_message * propagation_strategy
    | Discovery of match_discovery
    | Negotiation of negotiation_message
    | Settlement of settlement_message
    | StateSync of { from: timestamp; to: timestamp; proofs: proof list }
  
  (* Peer discovery *)
  type peer_discovery =
    | Bootstrap of { seeds: endpoint list }
    | MDNS  (* Local network discovery *)
    | DHT_Crawl
    | Introduction of { via: public_key }
end
```

### Ontology Protocol

```ocaml
module Ontology = struct
  (* Resources need semantic understanding *)
  type resource_ontology = {
    uri: uri;  (* e.g., "compute:gpu:nvidia:4090" *)
    parent: uri option;  (* inheritance hierarchy *)
    properties: (string * property_type) list;
    conversions: (uri * conversion_function) list;
    equivalences: uri list;
  }
  
  (* Dynamic ontology updates *)
  type ontology_evolution =
    | ProposeResource of resource_ontology
    | VoteOnResource of uri * bool
    | ActivateResource of uri  (* After consensus *)
    | DeprecateResource of uri * uri  (* old -> new *)
end
```

### Settlement Execution

```ocaml
module Settlement = struct
  (* Settlements are deterministic state transitions *)
  let execute_settlement match_id settlement_point state =
    (* Verify pre-conditions *)
    let pre_state = capture_state state in
    assert (validate_settlement_point settlement_point match_id);
    
    (* Lock resources *)
    let locked_resources = 
      lock_resources_for_settlement settlement_point state in
    
    (* Perform atomic swap *)
    let new_state = 
      atomic_swap 
        settlement_point.from 
        settlement_point.to
        settlement_point.resources
        state in
    
    (* Generate proof *)
    let proof = generate_merkle_proof pre_state new_state in
    
    (* Create settlement message *)
    { settlement_id = new_uuid();
      match_id = match_id;
      settlement_point = settlement_point;
      pre_state = hash_state pre_state;
      post_state = hash_state new_state;
      execution_proof = proof;
      reversible_until = Some (now() + reversal_window);
      reversal_bond = calculate_bond settlement_point }
end
```

### Intent Lifecycle Functions

```ocaml
(* Intents aren't static - they evolve *)
type lifecycle_function =
  | Eternal  (* Always valid *)
  | Expiring of timestamp
  | Decaying of { 
      half_life: duration;
      floor: float }  (* Gradually becomes less attractive *)
  | Adaptive of {
      update_function: (market_state -> intent_message -> intent_message);
      update_interval: duration }  (* Intent evolves based on market *)
  | Contingent of {
      condition: state -> bool;
      on_false: lifecycle_action }

and lifecycle_action =
  | Withdraw
  | Transform of intent_message
  | Hibernate of duration
```

### Protocol Governance

```ocaml
module Governance = struct
  (* Protocol can evolve *)
  type protocol_change = {
    proposal_id: uuid;
    change_type: change_type;
    description: string;
    implementation: diff;
    voting_window: timestamp * timestamp;
    activation_delay: duration;
  }
  
  and change_type =
    | ParameterUpdate of { parameter: string; new_value: value }
    | AlgorithmUpdate of { component: string; new_algorithm: hash }
    | OntologyUpdate of ontology_evolution
    | EmergencyPause of { reason: string; duration: duration }
end
```

### Implementation Headers

```ocaml
(* Reference implementation structure *)
module ACP : sig
  module Core : sig
    val post_intent : intent_message -> unit
    val discover_matches : unit -> match_discovery list  
    val negotiate : match_id -> settlement_point -> negotiation_result
    val settle : match_id -> settlement_point -> settlement_message
  end
  
  module Network : sig
    val connect : endpoint -> connection
    val broadcast : network_message -> unit
    val subscribe : (network_message -> unit) -> subscription
  end
  
  module Trust : sig
    val verify_capability : capability_proof -> bool
    val calculate_reputation : public_key -> float
    val lock_collateral : collateral_lock -> lock_receipt
  end
end
```

### Protocol Constants

```ocaml
let protocol_version = "0.1.0"
let matching_interval = 100 * milliseconds
let reversal_window = 30 * seconds  
let reputation_decay = 0.95  (* per epoch *)
let min_collateral_ratio = 1.1
let pareto_samples = 1000  (* for frontier computation *)
let max_negotiation_rounds = 10
let intent_ttl_default = 24 * hours
```

---

This protocol embodies our theory: intents as persistent fields, continuous matching, multi-dimensional negotiation, and emergent complexity from simple rules. 

The beauty is that it's **transport agnostic** (works over TCP, UDP, blockchain, or carrier pigeons), **settlement agnostic** (can use fiat, crypto, or barter), and **resource agnostic** (anything can be traded).

Should we dive deeper into any component? Or start sketching the reference implementation?