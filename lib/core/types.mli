(** Core type definitions for the Ambient Commerce Protocol *)

(** {1 Basic Types} *)

type uuid = string
(** Unique identifier for entities in the system *)

type public_key = string
(** Public key identifying an agent *)

type timestamp = float
(** Unix timestamp in seconds *)

type rational = {
  numerator: int;
  denominator: int;
}
(** Rational number for exact calculations *)

type resource_uri = string
(** URI identifying a resource type in the ontology *)

(** {1 Resource Types} *)

type quality = 
  | Fungible
  | Graded of float
  | Unique of string

type resource_field = {
  resource_type: resource_uri;
  quantity_range: float * float;
  quality: quality;
  metadata: (string * string) list;
}
(** Describes what an agent offers or wants *)

(** {1 Intent Types} *)

type constraint_t = 
  | TimeWindow of timestamp * timestamp
  | PriceRange of float * float
  | Counterparty of counterparty_req
  | Custom of string * string

and counterparty_req = {
  min_reputation: float option;
  required_capabilities: string list;
  excluded_agents: public_key list;
  preferred_agents: public_key list;
}

type lifecycle = 
  | Eternal
  | Expiring of timestamp
  | Consumable of int
  | Conditional of string

type intent = {
  intent_id: uuid;
  agent_id: public_key;
  offer_field: resource_field;
  want_field: resource_field;
  constraints: constraint_t list;
  lifecycle: lifecycle;
  created_at: timestamp;
  updated_at: timestamp;
  commitment: string;
  priority: float;
}
(** Core intent type - a declaration of economic desire *)

(** {1 Matching and Settlement Types} *)

type settlement_point = {
  price: float;
  quantity: float;
  execution_time: timestamp;
  quality_level: float option;
  additional_terms: (string * string) list;
}

type settlement_manifold = {
  dimensions: string list;
  valid_region_constraints: constraint_t list;
  pareto_frontier: settlement_point list;
  optimality_scores: (settlement_point * float) list option;
}

type match_t = {
  match_id: uuid;
  intent_ids: uuid list;
  settlement_space: settlement_manifold;
  discovered_at: timestamp;
  discovered_by: public_key;
  expires_at: timestamp;
}

type negotiation_state = 
  | Proposing
  | Negotiating of settlement_point list
  | Agreed of settlement_point
  | Failed of string

type settlement_status = 
  | Pending
  | Completed
  | Reversed of string
  | Failed of string

type settlement = {
  settlement_id: uuid;
  match_id: uuid;
  executed_point: settlement_point;
  execution_proof: string;
  pre_state_hash: string;
  post_state_hash: string;
  reversible_until: timestamp option;
  status: settlement_status;
  executed_at: timestamp;
}

(** {1 Reputation Types} *)

type reputation = {
  agent_id: public_key;
  score: float;
  total_settlements: int;
  successful_settlements: int;
  failed_settlements: int;
  total_volume: float;
  last_updated: timestamp;
  domain_scores: (resource_uri * float) list option;
}

(** {1 Network Types} *)

type message = 
  | IntentMessage of intent
  | MatchDiscovery of match_t
  | NegotiationMessage of uuid * negotiation_state
  | SettlementMessage of settlement
  | HeartbeatMessage of public_key * timestamp
  | ReputationUpdate of reputation

(** {1 Error Types} *)

type protocol_error = 
  | InvalidIntent of string
  | MatchingFailed of string
  | SettlementFailed of string
  | NetworkError of string
  | UnauthorizedError of string

(** {1 Helper Functions} *)

val create_uuid : unit -> uuid
val current_timestamp : unit -> timestamp

(** {1 JSON Conversion Functions} *)

(** These functions are generated by ppx_deriving_yojson *)
val resource_field_to_yojson : resource_field -> Yojson.Safe.t
val resource_field_of_yojson : Yojson.Safe.t -> (resource_field, string) Result.t